\documentclass{sigplanconf}[10pt]

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{PLATEAU '15}{October 26, 2015, Pittsburgh, PA, USA} 
\copyrightyear{2015} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Modularity's Multitudes}
% \subtitle{Subtitle Text, if any}

\authorinfo{Darya Kurilova \and Chris Martens}
           {Carnegie Mellon University}
           {\{darya, cmartens\}@cs.cmu.edu}

\maketitle

\begin{abstract}
We survey prevailing attitudes around the need for modularity in
programming languages and examine how these needs are met (or not) by
existing, concrete features in concurrent languages. The hypotheses we introduce
is that modularity contains a {\em multitude} of usability concerns,
and features called modules, packages, libraries, and objects, in various
languages, address distinct subsets of those concerns. 
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%programming languages, usability

\keywords
modularity, programming

\section{Introduction}

{\em Modularity} has been studied as a desirable property for designed
structures, within and outside of computing. In fields concerned with
physical manufacturing, a {\em modular} design is one composed of
standardized, interchangeable units, aimed at supporting recombination,
reuse, and easy replacement of failing parts. There are also implications
for human labor and assembly: independent manufacturers can specialize in
designing just one component, and these components can be combined
according to their interfaces without concern for the implementations of
the other components.  

In computing, modularity has struggled to define itself: naively, we want
similar properties, such as recombination, reuse, and interchangeability of
components that implement the same interface. However, software does not
innately contain mechanisms for enforcing the implementation-agnostic
properties of interfaces, the separability of dependencies, or clear
guidelines for {\em how} to separate the components of a system.  In addition, while
modularity may be formalized mathematically as a property of a language
feature or program (XXX cite derek), its importance unquestionably hinges
on human processes. 

In this paper we examine the core {\em human}-centered benefits of
modularity purported by the literature---specifically {\em
interoperability}, {\em reusability}, {\em extensibility}, {\em understandability},
and {\em performance}---and describe which features in modern languages
support these benefits. 
We define these terms as follows:

\begin{itemize}
  \item {\em Interoperability:} a module can work with other modules 
  without special effort on the part of the programmer.
  \item {\em Reusability:} an existing module can be used within the software
    development process for a purpose not originally intended.
  \item {\em Extensibility:} a software system's functionality can be enriched
    by adding new modules with minimal or no effect on the present system's 
    code.
  \item {\em Understandability:} by looking at the constituent modules of a 
    software system, a programmer, new to the system, can comprehend how 
    the system operates with minimal mental effort.
  \item {\em Performance:} compilation or interpretation of a software system's
    code should be time-efficient and proportionate to the size of changes made.
\end{itemize}

\section{Hypotheses}

{\em Modularity}, as a concept in programming, consists of many different
constructs, each with different usability benefits.

We state the following three hypotheses:

\begin{description}
    \item[H1:] Programming language designers tend to have similar goals in mind for
      adding ``modularity'' constructs to their languages, but the concrete
      features that they introduce solve distinct problems.
    \item[H2:] Modularity constructs intended to enable code reuse,
      comprehension of high-level program structure, and interoperability
      serve orthogonal purposes, i.e. programmers tend to use these
      constructs in ways for which the other constructs would not be
      suitable.
    \item[H3:] Novice programmers are often confused about the
      distinctions between different constructs for modularity and their
      alleged benefits. 
\end{description}

These hypotheses are {\bf important} and {\bf relevant}: the need for
modularity's benefits has been well-argued for decades, but these needs are
thwarted by an inadequate and confusing array of languages and features
claiming to support ``modularity.'' The hypotheses are {\bf useful} in that
they can add clarity to the zoo of languages and features that claim to
support modularity: we envision a future in which modularity feature
designers clearly assert which benefits they aim to support, and programmer
clients are less confused about their needs and how to meet them. 
% XXX this gets into a claim i'm not sure we decided to make...
 


\section{A Taxonomy of Modularity Features}

\subsection{Reuse}

\subsection{Comprehension}

\subsection{Separability}

\subsection{Interoperability}

\section{Examples}

Derek Dreyer's thesis:
~\cite{dreyer2005understanding}

MacQueen, ML module system:
~\cite{macqueen1984modules}

Parnas, criteria:
~\cite{parnas1972criteria}

Programming in the large:
~\cite{deremer1976programming}

\section{Conclusion}


\bibliographystyle{abbrvnat}
\bibliography{main}

\end{document}
